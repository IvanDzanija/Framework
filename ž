#ifndef MATRIX_PLU_H
#define MATRIX_PLU_H

#pragma once
#include "Matrix.hpp" // Assuming this contains the Matrix class and identity_matrix<T>

namespace maf::math {

/// PLU decomposition of square matrix.
/// Computes P, L, and U such that PA = LU.
/// P - permutation, L - lower triangular, U - upper triangular
///
/// P is saved as a std::vector<size_t> of size n, where P[i] is the
/// *original* row index that ends up at row i after pivoting.
///
/// More information:
/// https://en.wikipedia.org/wiki/LU_decomposition#LU_factorization_with_partial_pivoting
///
/// @param matrix The input square matrix A.
/// @return Tuple of std::vector P, Matrix L, Matrix U.
template <typename T>
[[nodiscard]] std::tuple<std::vector<uint32>, Matrix<T>, Matrix<T>>
plu(const Matrix<T> &matrix) {
    if (!matrix.is_square()) {
        throw std::invalid_argument(
            "Matrix must be square for PLU decomposition!");
    }

    const size_t n = matrix.row_count();
    if (n == 0) {
        // Handle empty matrix case
        return {std::vector<uint32>(), Matrix<T>(), Matrix<T>()};
    }

    std::vector<uint32> P(n);
    std::iota(P.begin(), P.end(), 0);

    Matrix<T> A_copy = matrix; // Work on a copy, which will become U
    Matrix<T> L = identity_matrix<T>(n);

    // Blocked LUP decomposition
    for (size_t ib = 0; ib < n; ib += BLOCK_SIZE) {
        const size_t block_end = std::min(ib + BLOCK_SIZE, n);

        // --- 1. Panel Factorization (Crout-style) ---
        // Factor columns ib..block_end and rows ib..n
        // This computes L_11, L_21, U_11 and updates P
        for (size_t i = ib; i < block_end && i < n - 1; ++i) {

            // --- 1a. Find Pivot ---
            // Find the row with the largest absolute value in column 'i',
            // starting from row 'i'.
            size_t pivot_row = i;
            T max_val = std::abs(A_copy.at(i, i));

            for (size_t j = i + 1; j < n; ++j) {
                T curr_val = std::abs(A_copy.at(j, i));
                if (curr_val > max_val) {
                    max_val = curr_val;
                    pivot_row = j;
                }
            }

            // --- 1b. Swap Rows ---
            if (pivot_row != i) {
                // Swap permutation vector
                std::swap(P[i], P[pivot_row]);

                // Swap entire rows in our working matrix A_copy
                auto row_i = A_copy.row_span(i);
                auto row_p = A_copy.row_span(pivot_row);
                std::ranges::swap_ranges(row_i, row_p);

                // Swap the *already computed* part of L (cols 0 to i-1)
                if (i > 0) {
                    auto l_row_i = L.row_span(i).subspan(0, i);
                    auto l_row_p = L.row_span(pivot_row).subspan(0, i);
                    std::ranges::swap_ranges(l_row_i, l_row_p);
                }
            }

            // --- 1c. Elimination (within panel) ---
            T pivot = A_copy.at(i, i);
            if (is_close(pivot, static_cast<T>(0), static_cast<T>(1e-9))) {
                continue;
            }

            const T inv_pivot = T(1) / pivot;

// For each row 'j' below the pivot row 'i'
// This loop is parallelizable.
#pragma omp parallel for schedule(static) if (n - (i + 1) > 256)
            for (size_t j = i + 1; j < n; ++j) {
                // Calculate the multiplier and store it in L
                T mult = A_copy.at(j, i) * inv_pivot;
                L.at(j, i) = mult; // This computes L_11 and L_21

// Update row j *within the panel* (cols i+1 to block_end)
// A_copy(j, k) = A_copy(j, k) - L(j, i) * A_copy(i, k)
#pragma omp simd
                for (size_t k = i + 1; k < block_end; ++k) {
                    A_copy.at(j, k) -= mult * A_copy.at(i, k);
                }
            }
        } // End Panel Factorization

        // --- 2. Update Trailing Matrix (Right-Looking Update) ---
        if (block_end < n) {

// --- 2a. [FIX] Triangular Solve for U_12 ---
// We must solve L_11 * U_12 = A_12 for U_12.
// L_11 is L(ib..block_end, ib..block_end) (unit lower triangular)
// A_12 is A_copy(ib..block_end, block_end..n)
// U_12 will be stored back into A_copy(ib..block_end, block_end..n)

// For each column j in A_12/U_12
// This loop is parallelizable as each column is independent.
#pragma omp parallel for schedule(static, 8) if (n - block_end > 128)
            for (size_t j = block_end; j < n; ++j) {
                // For each row i in L_11/A_12
                for (size_t i = ib; i < block_end; ++i) {
                    T sum = A_copy.at(i, j);
                    // sum -= L(i,k) * U(k,j)
                    // This inner loop is small (<= PLU_BLOCK_SIZE), so no simd
                    for (size_t k = ib; k < i; ++k) {
                        sum -= L.at(i, k) * A_copy.at(k, j);
                    }
                    A_copy.at(i, j) = sum; // A_copy(i,j) is now U_12(i,j)
                }
            }

// --- 2b. [Original] GEMM for A_22 ---
// Now compute A_22 = A_22 - L_21 * U_12
// L_21 is L(block_end..n, ib..block_end)
// U_12 is A_copy(ib..block_end, block_end..n) (computed in 2a)
// A_22 is A_copy(block_end..n, block_end..n)
#pragma omp parallel for schedule(static, 8) if (n - block_end > 128)
            for (size_t i = block_end; i < n; ++i) { // Row in A_22/L_21
                for (size_t k = ib; k < block_end;
                     ++k) {                    // Col in L_21 / Row in U_12
                    const T mult = L.at(i, k); // L_21(i, k)
                    if (is_close(mult, static_cast<T>(0),
                                 static_cast<T>(1e-9))) {
                        continue;
                    }

                    // Get row k of U_12
                    const T *u12_row = &A_copy.at(k, block_end);
                    // Get row i of A_22
                    T *a22_row = &A_copy.at(i, block_end);
                    const size_t len = n - block_end;

#pragma omp simd
                    for (size_t j = 0; j < len; ++j) {
                        a22_row[j] -= mult * u12_row[j];
                    }
                }
            }
        }
    } // end block loop (ib)

    // --- 4. Extract U ---
    // The upper triangular part of A_copy is now our U matrix.
    Matrix<T> U(n, n);
#pragma omp parallel for schedule(static) if (n > 256)
    for (size_t i = 0; i < n; ++i) {
        // Assuming U is default-initialized (all zeros)
        // Copy the upper-triangular row segment from A_copy to U
        T *u_row = &U.at(i, i);
        const T *a_row = &A_copy.at(i, i);
        const size_t len = n - i;
        std::copy_n(a_row, len, u_row);
    }

    return std::make_tuple(std::move(P), std::move(L), std::move(U));
}

} // namespace maf::math

#endif // MATRIX_PLU_H
